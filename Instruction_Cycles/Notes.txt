 Instruction Cycles
Registers Involved In Each Instruction Cycle: 
 

Memory address registers(MAR) : It is connected to the address lines of the system bus. It specifies the address in memory for a read or write operation.
Memory Buffer Register(MBR) : It is connected to the data lines of the system bus. It contains the value to be stored in memory or the last value read from the memory.
Program Counter(PC) : Holds the address of the next instruction to be fetched.
Instruction Register(IR) : Holds the last instruction fetched.
\

 The major steps in the instruction cycle are:

Fetch: In the fetch cycle, the CPU retrieves the instruction from memory. The instruction is typically stored at the address specified by the program counter (PC). The PC is then incremented to point to the next instruction in memory.
Decode: In the decode cycle, the CPU interprets the instruction and determines what operation needs to be performed. This involves identifying the opcode and any operands that are needed to execute the instruction.
Execute: In the execute cycle, the CPU performs the operation specified by the instruction. This may involve reading or writing data from or to memory, performing arithmetic or logic operations on data, or manipulating the control flow of the program.
There are also some additional steps that may be performed during the instruction cycle, depending on the CPU architecture and instruction set:
Fetch operands: In some CPUs, the operands needed for an instruction are fetched during a separate cycle before the execute cycle. This is called the fetch operands cycle.
Store results: In some CPUs, the results of an instruction are stored during a separate cycle after the execute cycle. This is called the store results cycle.
Interrupt handling: In some CPUs, interrupt handling may occur during any cycle of the instruction cycle. An interrupt is a signal that the CPU receives from an external device or software that requires immediate attention. When an interrupt occurs, the CPU suspends the current instruction and executes an interrupt handler to service the interrupt.


The Indirect Cycle is always followed by the Execute Cycle. The Interrupt Cycle is always followed by the Fetch Cycle. For both fetch and execute cycles, the next cycle depends on the state of the system.


  Here we will see how the Connection works 

                           Memory Hierarchy Flow

             Hard Drive / SSD (Secondary Storage)
                Super slow compared to CPU (measured in milliseconds for HDD, microseconds for SSD).
                   Holds programs and data permanently.
                      When you open a program → OS loads it from disk into RAM.
          RAM (Main Memory / DRAM)
                Much faster than storage (nanoseconds), but still too slow for CPU clock speeds.
                   Stores active program code + data temporarily.
                        CPU requests data → first looks into cache, not directly in RAM (because RAM is slower).
                                 

                                                      Cache Memory (SRAM, inside the CPU)
                Organized in levels:

               L3 Cache (largest, slowest, shared across cores).
                  L2 Cache (medium size, faster, usually per core or shared between few cores).
                     L1 Cache (smallest, fastest, directly attached to each core).

            When CPU needs data:
           Check L1 cache → if not found, go to L2 → if not found, go to L3 → if not found, fetch from RAM → if not in RAM, bring from storage (page swap).

               This process is called a cache hierarchy or memory hierarchy.
               Registers (inside CPU core)
               Even faster than cache.
               CPU executes instructions directly on data in registers.
               Data flows: Storage → RAM → Caches → Registers → ALU (processor logic).
